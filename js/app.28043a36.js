(function(e){function t(t){for(var a,s,r=t[0],l=t[1],c=t[2],h=0,b=[];h<r.length;h++)s=r[h],Object.prototype.hasOwnProperty.call(o,s)&&o[s]&&b.push(o[s][0]),o[s]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(e[a]=l[a]);u&&u(t);while(b.length)b.shift()();return i.push.apply(i,c||[]),n()}function n(){for(var e,t=0;t<i.length;t++){for(var n=i[t],a=!0,r=1;r<n.length;r++){var l=n[r];0!==o[l]&&(a=!1)}a&&(i.splice(t--,1),e=s(s.s=n[0]))}return e}var a={},o={app:0},i=[];function s(t){if(a[t])return a[t].exports;var n=a[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,s),n.l=!0,n.exports}s.m=e,s.c=a,s.d=function(e,t,n){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},s.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)s.d(n,a,function(t){return e[t]}.bind(null,a));return n},s.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="/eavesdropping-lamas/";var r=window["webpackJsonp"]=window["webpackJsonp"]||[],l=r.push.bind(r);r.push=t,r=r.slice();for(var c=0;c<r.length;c++)t(r[c]);var u=l;i.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("56d7")},"020a":function(e,t,n){e.exports=n.p+"img/interlock_4.099cd428.jpg"},"0ad8":function(e,t,n){},"1b6c":function(e,t,n){e.exports=n.p+"img/eavesdropping_3.3acba6e6.jpg"},"2c98":function(e,t,n){"use strict";n("5d6d")},"2d3d":function(e,t,n){},"2de7":function(e,t,n){e.exports=n.p+"img/perf_eve_kripke.2ae9fe52.png"},"56d7":function(e,t,n){"use strict";n.r(t);n("e260"),n("e6cf"),n("cca6"),n("a79d");var a=n("7a23"),o=(n("b0c0"),n("f51d")),i=n.n(o),s={class:"header navbar-fixed-top"},r={class:"navbar",role:"navigation"},l={class:"container"},c=Object(a["g"])("div",{class:"menu-container js_nav-item"},null,-1),u=Object(a["g"])("input",{class:"toggle-button",type:"checkbox",name:"toggle",id:"toggle"},null,-1),h=Object(a["g"])("label",{for:"navbar-toggle"},null,-1),b={class:"menu-mobile"},d={class:"collapse navbar-collapse nav-collapse"},m={class:"menu-container"},f={class:"nav navbar-nav container-right"},p={class:"js_nav-item nav-item"},g=Object(a["f"])("Home"),j={class:"js_nav-item nav-item"},O=Object(a["f"])("Encryption"),y={class:"js_nav-item nav-item"},w=Object(a["f"])("Methods"),v={class:"js_nav-item nav-item"},k=Object(a["f"])("Formalism"),$={class:"js_nav-item nav-item"},A=Object(a["f"])("Simulation"),B={class:"js_nav-item nav-item"},_=Object(a["f"])("Discussion"),E={class:"js_nav-item nav-item"},x=Object(a["f"])("References"),T={class:"view"},q=Object(a["g"])("img",{src:i.a,class:"bottom-right"},null,-1);function S(e,t,n,o,i,S){var C=Object(a["v"])("router-link"),I=Object(a["v"])("router-view");return Object(a["p"])(),Object(a["d"])("div",null,[Object(a["g"])("header",s,[Object(a["g"])("nav",r,[Object(a["g"])("div",l,[c,u,h,Object(a["g"])("div",b,[Object(a["g"])("div",d,[Object(a["g"])("div",m,[Object(a["g"])("ul",f,[Object(a["g"])("li",p,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"Home"===e.$route.name},to:{name:"Home"}},{default:Object(a["B"])((function(){return[g]})),_:1},8,["class"])]),Object(a["g"])("li",j,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"Encryption"===e.$route.name},to:{name:"Encryption"}},{default:Object(a["B"])((function(){return[O]})),_:1},8,["class"])]),Object(a["g"])("li",y,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"Methods"===e.$route.name},to:{name:"Methods"}},{default:Object(a["B"])((function(){return[w]})),_:1},8,["class"])]),Object(a["g"])("li",v,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"Formalism"===e.$route.name},to:{name:"Formalism"}},{default:Object(a["B"])((function(){return[k]})),_:1},8,["class"])]),Object(a["g"])("li",$,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"Simulation"===e.$route.name},to:{name:"Simulation"}},{default:Object(a["B"])((function(){return[A]})),_:1},8,["class"])]),Object(a["g"])("li",B,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"Discussion"===e.$route.name},to:{name:"Discussion"}},{default:Object(a["B"])((function(){return[_]})),_:1},8,["class"])]),Object(a["g"])("li",E,[Object(a["g"])(C,{class:{"nav-item-child":!0,activebutton:"References"===e.$route.name},to:{name:"References"}},{default:Object(a["B"])((function(){return[x]})),_:1},8,["class"])])])])])])])])]),Object(a["g"])("div",T,[Object(a["g"])(I,null,{default:Object(a["B"])((function(e){var t=e.Component;return[Object(a["g"])(a["a"],{name:"fade",mode:"in-out"},{default:Object(a["B"])((function(){return[(Object(a["p"])(),Object(a["d"])(Object(a["w"])(t)))]})),_:2},1024)]})),_:1})]),q])}var C={name:"App",mounted:function(){var e=document.createElement("script");e.setAttribute("src","https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"),e.setAttribute("id","MathJax-script"),e.async=!0,document.head.appendChild(e),window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}}};n("c877");C.render=S;var I=C,M=n("6c02"),R=Object(a["C"])("data-v-47798d78");Object(a["s"])("data-v-47798d78");var F={class:"blog"},W=Object(a["g"])("h1",null,"Introduction",-1),H=Object(a["g"])("span",{class:"first-letter"},"C",-1),N=Object(a["f"])("ommunication is information in motion"),L=Object(a["f"])(", the dynamics of which are described by the changing knowledge and beliefs for some set of agents. Remembering that knowledge is power, agents may wish to carefully control the flow of information in a system by way of "),K=Object(a["f"])("private communication"),P=Object(a["f"])(". This proves to be a non-trivial task when a third-party agent wishes to "),D=Object(a["f"])("eavesdrop"),z=Object(a["f"])(" on an information exchange. The archetypical defense against eavesdropping is "),J=Object(a["f"])("encryption"),U=Object(a["f"])(", whereby the true meaning of messages are disguised by an encoding that is uniquely readable to the agent for which a message is intended. However, an eavesdropping agent may employ a trick such that communicating agents believe they are encoding messages for their partner, but instead encode them for the eavesdropper. How then can private communication be achieved? Can communicating agents ever know that their exchange of information is indeed private? "),G=Object(a["f"])(' Here we present three cases of "private communication" as outlined, along with graphic simulations in the spirit of, and novel epistemic formalism. First we illustrate a basic RSA encryption protocol with the case of perfect, deletion-error-free communication between two agents, Alice and Bob. We then demonstrate how this method is vulnerable to breeches in privacy through belief-manipulation with the introduction of an eavesdropping agent Eve. Finally, we present the "interlocks" protocol ['),V=Object(a["f"])("2"),Q=Object(a["f"])("] as a solution to the eavesdropping, whereby Alice and Bob are guaranteed to become aware of the presence of Eve and may therefore cease communication on that compromised line. "),X=Object(a["f"])(' At this point, you may be asking yourself, "Why bother with privacy? I\'ve got nothing to hide." Luckily, we may refer you to ['),Y=Object(a["f"])("4"),Z=Object(a["f"])("], wherein you will find that you indeed do have an interest in maintaining privacy whenever possible in personal communication. The need for privacy extends much farther than revolutionaries, spies, and nefarious agents. "),ee=Object(a["g"])("br",null,null,-1),te=Object(a["f"])(" As aforementioned, knowledge is power. Knowledge "),ne=Object(a["f"])("about"),ae=Object(a["f"])(" us can be wielded as power "),oe=Object(a["f"])("over"),ie=Object(a["f"])(" us. If we are laissez-faire with who can listen in on our communication, then we have no way of knowing what their interest in our information might be. From targeted advertisement to predicting our behaviour to a deliberate shifting of our political views, the more that is known about us, the more effectively we may be influenced. The first step in protecting ourselves from listeners with unknown intent is to know in what cases we are being listened to. When are we in the presence of an Eve? ");Object(a["q"])();var se=R((function(e,t,n,o,i,s){var r=Object(a["v"])("it"),l=Object(a["v"])("router-link");return Object(a["p"])(),Object(a["d"])("div",F,[W,Object(a["g"])("p",null,[H,Object(a["g"])(r,null,{default:R((function(){return[N]})),_:1}),L,Object(a["g"])(r,null,{default:R((function(){return[K]})),_:1}),P,Object(a["g"])(r,null,{default:R((function(){return[D]})),_:1}),z,Object(a["g"])(r,null,{default:R((function(){return[J]})),_:1}),U]),Object(a["g"])("p",null,[G,Object(a["g"])(l,{to:{name:"References"}},{default:R((function(){return[V]})),_:1}),Q]),Object(a["g"])("p",null,[X,Object(a["g"])(l,{to:{name:"References"}},{default:R((function(){return[Y]})),_:1}),Z,ee,te,Object(a["g"])(r,null,{default:R((function(){return[ne]})),_:1}),ae,Object(a["g"])(r,null,{default:R((function(){return[oe]})),_:1}),ie])])})),re={name:"Home",data:function(){return{formula:""}}};n("b82f");re.render=se,re.__scopeId="data-v-47798d78";var le=re,ce=Object(a["C"])("data-v-8b16aab6");Object(a["s"])("data-v-8b16aab6");var ue={class:"blog"},he=Object(a["g"])("h1",null,"Simulation",-1),be=Object(a["g"])("p",null," This page gives a description of the simulation below, as well as the link to the code itself. The code needs to be run on your own computer and cannot be run in this browser. ",-1),de=Object(a["g"])("a",{href:"https://github.com/Brandsma/LAMAS",target:"_blank",rel:"noopener noreferrer"},[Object(a["g"])("button",{class:"github-button"},[Object(a["g"])("div",{class:"button-content"},[Object(a["g"])("img",{style:{width:"20%"},src:"https://img.icons8.com/fluent/48/000000/github.png"}),Object(a["f"])("Project Code ")])])],-1),me=Object(a["e"])('<h2 data-v-8b16aab6>Overview of the model</h2><p data-v-8b16aab6> The model mainly consists of a communication framework between two agents, originally based on the LOKWebs assignments. Two agents communicate messages through a channel which they do not operate. Agents send confirmation messages up until the confirmation depth is achieved, at which point they know that the other has received knowledge of an order which is satisfactory. From this base many features are added; communication using encryption, two-way communication, eavesdropping, the eavesdrop detecting interlock protocol, and any (theoretically possible) permutation of these features. <br data-v-8b16aab6> The design of the model places a high priority on modularity and sound architecture. This is made apparent by the ease of integration between the different modes of operation. <br data-v-8b16aab6> Thoughout the model care is taken to comment where explanation of the model is required. Comments are often notes for the programmer, but also do a good job explaining the why of a piece of code to the technical reader. </p><h2 data-v-8b16aab6>Model entities</h2><pre data-v-8b16aab6>Process : The highest level entity, used mainly to keep track of the order of events using Lamports time \n          algorithm for distributed systems. (I would have loved to upgrade to vector clocks, \n          but priorities lay elsewhere)\n\n    Channel : A one-way communication channel facilitating communication between agents. \n              Modular design using buffers.\n\n    Agent : A communicating entity -- capable of message handling, connecting with channels, encryption \n            and interlock protocols, different reporters.\n        Sender : A subtype of an agent harbouring the capabilties of producing, sending and \n                 acknowledging messages.\n        Receiver : A subtype of an agent harbouring the capabilities of receiving and \n                   acknowledging messages.\n            Communicator : A subtype of an agent inheritting from both Sender and Receiver, used for \n                           two-way communication\n\n    Eavesdropper : Eavesdropper process, utilizing two agents spoofing connection to the &#39;real&#39; \n                   communicators. Real Alice meet Fake Bob, Real Bob meet Fake Alice.\n\n    Message : An object used as communication vessel.\n\nStepper : Controlling entity scheduling when which process acts. \n</pre><h2 data-v-8b16aab6>Basic model loop</h2><p data-v-8b16aab6> The stepper controls which process acts at which point. It does so sequentially. A sending agent prepares their message they want to send by placing it in their outgoing buffer. The message is moved from their outgoing buffer to the incomming buffer of their outgoing-connected channel. From there it is moved to that channels &#39;chute&#39;, which then transfers the message to its outgoing buffer. From there the message is moved to the incomming buffer of the receiving agent. The receiving agent reads the message, decides whether or not to acknowledge the message (and place it in their own outgoing buffer), to store the message, or to respond with their own message (two-way communication). The process is repeated symetrically using a different channel. When there is an eavesdropper in the model, it hijacks the communication channels and places its own spoofed agents on either side. This means there are now four communication channels instead of two. The eavesdropper transfers messages received on one side to the other side, to give the illusion the unknowing agents are speaking to eachtoher without anyone listening. With encryption, agents first produce their private/public key pair and exchange public keys. They will encrypt their outgoing messages with the public key received from the other party, and decrypt incomming ciphertext with their own private key. The encryption algorithm used is RSA. Encryption is applied when transfering their message from their output buffer to the channels input buffer. With the interlock protocol, agents split their outgoing message (after encryption) when transfering their message from their output buffer to their outgoing channels input buffer. A message is split in half, the remaining half is stored and sent (only) after receiving a new message (that is not an acknowledge) by the other party. </p><h2 data-v-8b16aab6>How to run the program (basic):</h2><pre class="code" data-v-8b16aab6>run &quot;python main.py&quot;\n</pre><h2 data-v-8b16aab6>&quot;What is the output?&quot;:</h2><p data-v-8b16aab6> The output of the model shows the messages each agent has in their sending and receiving list, both at the start and the end of the model. This shows that the model is working properly and messages intended to send are sent and received. It also shows that the eavesdropper knows the messages. A highly detailed log of what happens can be enabled by setting &quot;print_log_to_terminal&quot; and/or &quot;print_channel_content&quot; to true in the config.py file.<br data-v-8b16aab6> Note that when encryption is turned on, output can be more messy, as encryption keys and encrypted texts are long and machine-readable. </p><h2 data-v-8b16aab6>How to change the model / experiment with settings:</h2><p data-v-8b16aab6> Most of the relevant settings can be found in the &quot;config.py&quot; file. At the top of this file the reader will find many switches for different modes of running the program: </p><ul data-v-8b16aab6><li data-v-8b16aab6> encryption_protocol (Will agents use encryption when communicating?) </li><li data-v-8b16aab6> include_eavesdropper (Is there an eavesdropper through which the agents communicate?) </li><li data-v-8b16aab6> two_way_communication (Is communication one or two way? Two way means both send and receive message content. One-way still includes acknowledges from the receiver) </li><li data-v-8b16aab6> interlock_protocol (Is the interlock protocol employed in communication?) </li></ul><p data-v-8b16aab6>As well as operating parameters:</p><ul data-v-8b16aab6><li data-v-8b16aab6> stepper_time_limit (How many steps the program will take, recommended to keep at 300+ to see a full execution) </li><li data-v-8b16aab6> message_timeout (How long an agent waits before resending a message -- setting to a value other than 1 can produce strange behaviour) </li><li data-v-8b16aab6> acknowledge_depth (The number of acknowledges required in total -- can be seen as the &quot;order of theory of mind-level&quot; parameter, recommended to read the warning messages below before changing.) </li></ul><p data-v-8b16aab6> Some failure model parameters, not yet properly implemented (but can be done with easy, if the instructor of the course is interested in a better version of the LOKwebs model ;) --&gt; contact Ivo) </p><p data-v-8b16aab6>Some output parameters:</p><ul data-v-8b16aab6><li data-v-8b16aab6> save_log_to_file (Save a log trace of all actions/states to file, used for the animations) </li><li data-v-8b16aab6> print_log_to_terminal (Print the log trace of all actions to the terminal, for debugging and inspection) </li><li data-v-8b16aab6> print_channel_content (Print the channel content at certain moments to the terminal. Not as expressive as the log trace, but more easy to read) </li><li data-v-8b16aab6> loglevel (Log statements thoughout the model, can be set at logging.DEBUG for most expressive, then logging.INFO, logging.WARNING, logging.ERROR for least expressive) </li></ul><h2 data-v-8b16aab6>How to run the modes manually (advanced):</h2><p data-v-8b16aab6> The model runs from the file main.py, which calls the communication_demo.py file. This file describes the protocol that is initiated for a single run. The advanced user can observe the order components initialized and invoked here. Changes in here should be limited to changing the message content and switching connections. For any really advanced changes, reading the documentation of the structure and entities is strongly recommended. </p><h2 data-v-8b16aab6>&quot;Why does this not work?&quot;</h2><p data-v-8b16aab6> Certain parameter combinations are theoretically incongruent. Most notably: </p><ul data-v-8b16aab6><li data-v-8b16aab6> an uneven value for the acknowledge_depth parameter is required for one-way communication </li><li data-v-8b16aab6> an even value for the acknowledge_depth parameter is required for two-way communication </li><li data-v-8b16aab6> a value of 0 for the acknowledge_depth parameter is required for the interlock_protocol </li><li data-v-8b16aab6>the interlock_protocol requires two-way communication</li><li data-v-8b16aab6> (!) the interlock_protocol combined with the eavesdropper will result in a decryption error </li></ul><h2 data-v-8b16aab6>Note about the logic folder</h2><p data-v-8b16aab6> The logic folder houses some code that was intended to be used for knowledge representation in the model and includes an automatic solver for S5-like models. During the project, we decided that the knowledge-side of the project was more suited to be modelled statically. This can be found on the website under the &#39;Formalism&#39; section. </p>',25);Object(a["q"])();var fe=ce((function(e,t,n,o,i,s){return Object(a["p"])(),Object(a["d"])("div",ue,[he,be,de,Object(a["g"])("p",null,[Object(a["g"])("button",{type:"button",onClick:t[1]||(t[1]=function(){return s.toggleCollapsible&&s.toggleCollapsible.apply(s,arguments)}),class:{collapsible:!0,active:i.isShowingCollapsible}}," Show Project README ",2)]),Object(a["g"])("div",{class:{content:!i.isShowingCollapsible,"content-not-hidden":i.isShowingCollapsible}},[me],2)])})),pe={name:"Simulation",data:function(){return{isShowingCollapsible:!1}},methods:{toggleCollapsible:function(){this.isShowingCollapsible=!this.isShowingCollapsible}}};n("ef76");pe.render=fe,pe.__scopeId="data-v-8b16aab6";var ge=pe,je={class:"blog"},Oe=Object(a["g"])("img",{class:"image",src:"https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.hdnicewallpapers.com%2FWalls%2FBig%2FCat%2FBeautiful_Angry_Kitten.jpg&f=1&nofb=1",alt:"It's a cat"},null,-1);function ye(e,t,n,o,i,s){return Object(a["p"])(),Object(a["d"])("div",je,[Object(a["g"])("h1",null,Object(a["y"])(e.$route.name),1),Oe])}var we={name:"Methods"};we.render=ye;var ve=we,ke=n("81a2"),$e=n.n(ke),Ae=n("63b4"),Be=n.n(Ae),_e=n("8311"),Ee=n.n(_e),xe=n("2de7"),Te=n.n(xe),qe=n("68fc"),Se=n.n(qe),Ce=n("d47f"),Ie=n.n(Ce),Me=n("1b6c"),Re=n.n(Me),Fe=n("d30d"),We=n.n(Fe),He=n("99aa"),Ne=n.n(He),Le=n("91e8"),Ke=n.n(Le),Pe=n("020a"),De=n.n(Pe),ze=Object(a["C"])("data-v-06f47628");Object(a["s"])("data-v-06f47628");var Je={class:"blog"},Ue=Object(a["g"])("h2",null,"Perfect Communication - S5 Model",-1),Ge=Object(a["f"])(" Let us now abstract to the simplest scenario where Alice has only two possible public keys, and Bob has only two possible messages to communicate with Alice. Realize that the fundamental logic of this abstraction holds symmetrically for communication in the opposite direction, as well as iterativily for any number of possible keys and messages. In fact, we invite you to imagine that the first possible public key for Alice represents her actual key, and the second key stands in for "),Ve=Object(a["f"])("all possible other keys"),Qe=Object(a["f"])('. Likewise, please think of Bob\'s first possible message as his actual message, and the second possible message as all possible other messages. The logic and relations work the same whether these secondary keys and messages are inductively expanded or collapsed. For a similar example of "inductive collapse", we refer the reader to ['),Xe=Object(a["f"])("1"),Ye=Object(a["f"])("]. As a final note, the reflexivity relationships have not been drawn for simplicity's sake. "),Ze=Object(a["f"])(" In the first figure below, we may see the epistemic states unfold for this simplified communication, where there are only two possible public keys for Alice ( "),et=Object(a["f"])(" and "),tt=Object(a["f"])(" ), and two possible messages Bob might send ("),nt=Object(a["f"])("p"),at=Object(a["f"])(" and "),ot=Object(a["f"])("q"),it=Object(a["f"])("). "),st=Object(a["f"])(" Here we assume that in the initial state (top-left in the figure), Alice knows her key and Bob knows the message he wants to send. Therefore, Alice cannot distinguish between "),rt=Object(a["f"])(" and "),lt=Object(a["f"])(", while Bob cannot distinguish between "),ct=Object(a["f"])(" and "),ut=Object(a["f"])(". This is described by the appropriate accessibility relations which indicate which worlds must be simultaneously accepted as possible for a given agent. Note, all worlds have reflexive relations for all agents and that these are "),ht=Object(a["f"])("S5-Kripke structures."),bt=Object(a["f"])(" Once Bob receives Alice's public key, Bob now knows whether it is "),dt=Object(a["f"])(" or "),mt=Object(a["f"])(". He cannot accept both of these states as simultaneously true and therefore all accessibility relations between the two possible public keys drop out. Now that "),ft=Object(a["f"])(", Bob may correctly encrypt his message (either "),pt=Object(a["f"])(" or "),gt=Object(a["f"])(") and send it to Alice. "),jt=Object(a["g"])("img",{src:$e.a,alt:"Image perf_kripke"},null,-1),Ot=Object(a["g"])("p",null," Alice then receives Bob's message and decrypts it with her private key, finally alleviating any remaining indistinguishability. Thus information has been fruitfully shared and everyone knows everything. While this type of model does show each state correctly, it does not give a clear representation of the steps that are taken in between. It is also not a prerequisite for the model to first have received the key before sending the message. These issues will be resolved with action models. ",-1),yt=Object(a["g"])("h2",null,"Perfect Communication - Action Model",-1),wt=Object(a["f"])(" Here we present the first action model. Before getting into the details of the situation at hand, there are a few important distinctions to be noted for all action models that we present. First of all, the "),vt=Object(a["f"])("true"),kt=Object(a["f"])(" world is represented by a thick line. Secondly, the kripke structures that are shown here are no longer "),$t=Object(a["f"])("S5-Kripke structures"),At=Object(a["f"])(", but rather "),Bt=Object(a["f"])(" , which includes everything from "),_t=Object(a["f"])("S5"),Et=Object(a["f"])(" and in addition adds the concept of "),xt=Object(a["f"])("actions"),Tt=Object(a["f"])(". For more information about this subject, see ["),qt=Object(a["f"])("3"),St=Object(a["f"])("]. "),Ct=Object(a["g"])("p",null," Now back to communicating. In the initial state, we assume Bob knows which message he will send and Alice knows which key is hers. Logically, there are two possible keys for Bob to receive, but in reality there is only one (A1). His reception of the key defines the first action of the model and results in the new Kripke model on the right. ",-1),It=Object(a["g"])("img",{src:Be.a,alt:"Image perfect_communication_1"},null,-1),Mt=Object(a["f"])(" The second action in the protocol whereby Bob sends his message and Alice receives defines the preconditions "),Rt=Object(a["f"])(" and "),Ft=Object(a["f"])(" which result in the union visualized in the final Kripke structure on the right. "),Wt=Object(a["g"])("img",{style:{},src:Ee.a,alt:"Image perfect_communication_2"},null,-1),Ht=Object(a["g"])("div",{class:"CENTER"},null,-1),Nt=Object(a["g"])("h2",null,"Eavesdropping",-1),Lt=Object(a["g"])("h3",null,"S5 Model",-1),Kt=Object(a["g"])("p",null," In terms of epistemic logic, we now see certain nuances emerge. What is of special interest is the false belief that Alice and Bob have concerning whose public key they receive. Again, we can consider the simplified case of Alice sending one of two possible public keys, and Bob sending one of two possible messages. Again, the logic derived here can be extended to an infinite number of possible keys and messages by induction. Note that Eve's public key is also modelled, but only as one possible key. However, this can also be expanded by induction to arbitrarily many public keys. Please note that these step-by-step Kripke models fail to model key ownership as perceived by Bob. In order to incorporate Eve's deception of Bob formally, action models will be needed and are included in the next section. ",-1),Pt=Object(a["g"])("p",null," Considering the figure below with the S5 kripke models from left-to-right, and then downward: ",-1),Dt=Object(a["g"])("ul",null,[Object(a["g"])("li",null," In the initial state, Bob can distinguish between no public keys and thus must consider all key nodes simultaneously possible through accessibility relations. Bob does know the content of his own prospective message however, and so there are no lateral relations for Bob between possible messages. While Alice cannot distinguish between possible messages of Bob, she does know the difference between her own possible keys and Eve's key and therefore has no accessibility relations between these nodes. Eve can only discern a difference between her own public key and Alice's public key at this point, and must accept all other possibilities at this point in time. "),Object(a["g"])("li",null," After Eve receives Alice's public key she can now drop the accessibility relations between Alice's possible keys. "),Object(a["g"])("li",null," Once Bob receives Eve's public key (thinking that it is Alice's), all key worlds become mutually exclusive for Bob as well. "),Object(a["g"])("li",null," Upon receiving and decrypting Bob's message, Eve now may distinguish all possible message nodes. "),Object(a["g"])("li",null," Once Alice finally receives Bob's message (encrypted with Eve's key), she can decrypt it with what she thinks is Bob's public key (though it is Eve's) and finally, everyone may distinguish all possible states and the information is shared. ")],-1),zt=Object(a["g"])("p",null," The obvious issue with this situation is that Alice and Bob may very well wish to keep there information private. ",-1),Jt=Object(a["g"])("img",{src:Te.a,alt:"Image perf_eve_kripke"},null,-1),Ut=Object(a["g"])("h3",null,"Action Model",-1),Gt=Object(a["f"])(" The introduction of an eavesdropper greatly expands the epistemic dynamics of the system, and in fact modelling the caveat that Bob believes he has Alice's key when he truly has Eve's key expands the combinatorics of the Kripke structures to an infeasible degree if full nodal representation would be kept. We therefore again rely heavily on \"inductive collapse\" whereby we may assume that all possible keys are contained in a single nodal representation of that key, mainly focusing on the actual keys of Alice, Bob, and Eve. Besides message "),Vt=Object(a["f"])("p"),Qt=Object(a["f"])(", we will maintain the extra possible message "),Xt=Object(a["f"])("q"),Yt=Object(a["f"])(" (standing in for all possible messages besides the actual message) to aid in understanding the development of the agents their knowledge. Furthermore, realize we are again confining our model to the unidirectional circumstance of Bob wanting to get a message to Alice. By symmetry, this could of course define the same logic as the other way around–just swap the names. "),Zt=Object(a["f"])(" In the initial state (refer to the correct pictures), we have only two nodes, both contain the two public keys involved in the system (Alice's and Eve's) and otherwise being split between Bob's two possible message "),en=Object(a["f"])(" p "),tn=Object(a["f"])(" (his real message) or "),nn=Object(a["f"])(" q "),an=Object(a["f"])(" (all other possible messages). On this initial state, the action-point "),on=Object(a["f"])(", related to the initial model by the precondition "),sn=Object(a["f"])(" , holds at every node and therefore the action-point is added to each node, resulting the new kripke model with action-points "),rn=Object(a["f"])(" Intuitively, this establishes that in all possible worlds, Eve has received Alice's public key. "),ln=Object(a["f"])(" From the newly derived Kripke model, we again model an event that will change our kripke structure. The action points here are Bob either receiving Alice's key or Eve's key ( "),cn=Object(a["f"])(" or "),un=Object(a["f"])(" both of which are defined by the precondition of those keys existing, such that "),hn=Object(a["f"])(" and "),bn=Object(a["f"])(". Importantly, Alice and Bob cannot possibly distinguish between these two actions points, and therefore their accessibility relations between these two possibilities creates a new model dimension, resulting in the new Kripke structure, with separate pairs of nodes for Bob either having Alice's key or Eve's key. "),dn=Object(a["f"])(" The next event simply adds the action points by which Eve receives Bob's message ( "),mn=Object(a["f"])(" and "),fn=Object(a["f"])("), with preconditions "),pn=Object(a["f"])(" and "),gn=Object(a["f"])(" thereby removing her accessibility relations between all worlds separated only by "),jn=Object(a["f"])(" and "),On=Object(a["f"])(" These action points are still indistinguishable by Alice, so her accessibility relations remain. "),yn=Object(a["f"])(" Finally, Alice receives Bob's message (as passed through Eve) and thus the action points "),wn=Object(a["f"])(" and "),vn=Object(a["f"])(" are added with no accessibility relations, thus breaking the finally horizontal accessibility relations of model–meaning that all agents have learned Bob's message. We can form similar preconditions here as for the previous event, namely "),kn=Object(a["f"])(" and "),$n=Object(a["g"])("p",null," Thus, with the aid of action models, we have modelled the important fact that while Bob's information is successfully passed, Bob and Alice never become aware of the difference between Eve's public key and Alice's. Therefore, Eve may successfully and discretely eavesdrop on all of Alice and Bobs' communication. ",-1),An=Object(a["g"])("img",{src:Se.a,alt:"Image eavesdropping_1"},null,-1),Bn=Object(a["g"])("div",{class:"CENTER"},null,-1),_n=Object(a["g"])("img",{src:Ie.a,alt:"Image eavesdropping_2"},null,-1),En=Object(a["g"])("div",{class:"CENTER"},null,-1),xn=Object(a["g"])("img",{class:"final-step",src:Re.a,alt:"Image eavesdropping_3"},null,-1),Tn=Object(a["g"])("div",{class:"CENTER"},null,-1),qn=Object(a["g"])("h2",{id:"interlock-anchor"},"The interlock protocol",-1),Sn=Object(a["g"])("h3",null,"Action Model",-1),Cn=Object(a["f"])(" While the protocol seems to increase in complexity, the associated formalism barely does. Many of the events are similar when compared to the previous two situations that we have shown, the main difference being that more messages are being sent "),In=Object(a["f"])("and"),Mn=Object(a["f"])(" that the full message is not know until later. The fact that the full message is not known until later makes this a very epistemically interesting situation. We can see this clearly in an action model. This time we will only show the action model as it may be clear by now that the usual "),Rn=Object(a["f"])("S5"),Fn=Object(a["f"])(" worlds do not suffice to capture the nuances of eavesdropping. As before, we have two separate messages, message "),Wn=Object(a["f"])("p"),Hn=Object(a["f"])(" and message "),Nn=Object(a["f"])("q"),Ln=Object(a["f"])(" and two separate keys "),Kn=Object(a["f"])(" and "),Pn=Object(a["f"])(". The messages are now broken up into two parts and the content of half a message cannot be properly deciphered (due to cryptographic reasons). Both halves of "),Dn=Object(a["f"])("p"),zn=Object(a["f"])(" are needed in order to "),Jn=Object(a["f"])("know"),Un=Object(a["f"])(" the content of message "),Gn=Object(a["f"])("p"),Vn=Object(a["f"])(". The simple addition of breaking the message up into two parts helps the agents discern whether or not there is an eavesdropper in the mix as was explained in the "),Qn=Object(a["f"])("methods"),Xn=Object(a["f"])(" section. We use one simplification in the modelling of this situation. Usually, the interlock protocol requires two-way communication, otherwise Bob would not know when to send the next part of the message. If Bob simply follows the first message directly by the second, then Eve can simply wait for the second half to arrive. We assume that Eve does not use this stalling tactic here and simply sends the message on directly. "),Yn=Object(a["g"])("p",null,"We can now walk through each step of the protocol using action logic:",-1),Zn=Object(a["g"])("p",null,null,-1),ea=Object(a["f"])(" In the initial state, (refer to correct pictures) there are two nodes that differ based on the possible message to be sent by Bob (denoted by the prepositions "),ta=Object(a["f"])(" and "),na=Object(a["f"])(', read "message p from Bob"). Alice and Eve are unable to distinguish between these worlds in the first step, because they have not received any messages yet. The event '),aa=Object(a["f"])(' (read "Eve receives pubA") is linked to both nodes through the precondition '),oa=Object(a["f"])(" After Eve receives Alice her public key, she sends Bob one of the keys she has in possession. This can be her own or Alice her key. She chooses to send her own key, because that makes it possible to eavesdrop. Both actions are dependent on the preconditions "),ia=Object(a["f"])(" and "),sa=Object(a["f"])(". Alice and Bob are both unable to discern between which key has been sent. Alice has no idea which key was sent and Bob is unable to discern the difference, so he believes it to be Alice her key. This adds extra dimensionality to the model, because of extra uncertainty relationships. "),ra=Object(a["f"])(" The model that follows from the previous step is the point where the keys have been fully exchanged. Now the messages can be sent. The first half of the message is being sent (which is represented by "),la=Object(a["f"])(', read "Eve receives message p[0] from Bob"). There are two distinct actions '),ca=Object(a["f"])(" and "),ua=Object(a["f"])(", and the associated preconditions "),ha=Object(a["f"])(" and "),ba=Object(a["f"])(". These preconditions link it to the correct worlds in the Kripke model. "),da=Object(a["f"])(" This step is much the same as the previous step, but now Alice receives the message. There are technically two options for Eve here. She can either send the message Bob send, which Alice cannot decrypt due to having the wrong key. Or she can make up her own message, which is most likely not going to be the same as Bob's message. To model Alice receiving half the message from Bob (unaltered), we can use "),ma=Object(a["f"])(" and "),fa=Object(a["f"])(" Now Bob sends the second part of the message. This is the first part where some accessibility relationships start changing and agents start to learn information. Once Eve receives Bob's second message, she will know "),pa=Object(a["f"])(" meaning she can distinguish between the worlds with "),ga=Object(a["f"])(" and "),ja=Object(a["f"])(". The prepositions "),Oa=Object(a["f"])(" and "),ya=Object(a["f"])(" is added to the model with the preconditions "),wa=Object(a["f"])(" and "),va=Object(a["f"])(". "),ka=Object(a["f"])(" Now Alice receives the second part of the message from Eve as she tries to remain transparent to avoid detection. The actions are much the same with "),$a=Object(a["f"])(" and "),Aa=Object(a["f"])(". There is one important caveat here though. Since the message was encrypted with Eve's public key and not Alice her public key, Alice is now unable to decrypt the message. She is unable to read the contents of the message, so therefore she cannot distinguish between those worlds. But she does know that a different public key was used to encrypt the message, which implies that there is an eavesdropper in the middle. This leads us to the final kripke model. "),Ba=Object(a["g"])("p",null," We can see that the action model does not actually become much more complex than before. It is a relatively simple protocol that leads to interesting epistemic results, because the final kripke model is significantly different than with eavesdropping. So, are we now in the presence of an Eve? Indeed, it seems so. ",-1),_a=Object(a["g"])("img",{style:{},src:We.a,alt:"Image interlock_1"},null,-1),Ea=Object(a["g"])("img",{style:{},src:Ne.a,alt:"Image interlock_2"},null,-1),xa=Object(a["g"])("img",{style:{},src:Ke.a,alt:"Image interlock_3"},null,-1),Ta=Object(a["g"])("img",{class:"final-step",src:De.a,alt:"Image interlock_4"},null,-1);Object(a["q"])();var qa=ze((function(e,t,n,o,i,s){var r=Object(a["v"])("it"),l=Object(a["v"])("router-link"),c=Object(a["v"])("math-jax");return Object(a["p"])(),Object(a["d"])("div",Je,[Object(a["g"])("h1",null,Object(a["y"])(e.$route.name),1),Ue,Object(a["g"])("p",null,[Ge,Object(a["g"])(r,null,{default:ze((function(){return[Ve]})),_:1}),Qe,Object(a["g"])(l,{to:{name:"References"}},{default:ze((function(){return[Xe]})),_:1}),Ye]),Object(a["g"])("p",null,[Ze,Object(a["g"])(c,{formula:"$pubA1$"}),et,Object(a["g"])(c,{formula:"$pubA2$"}),tt,Object(a["g"])(r,null,{default:ze((function(){return[nt]})),_:1}),at,Object(a["g"])(r,null,{default:ze((function(){return[ot]})),_:1}),it]),Object(a["g"])("p",null,[st,Object(a["g"])(c,{formula:"$mBp$"}),rt,Object(a["g"])(c,{formula:"$mBq$"}),lt,Object(a["g"])(c,{formula:"$pubA1$"}),ct,Object(a["g"])(c,{formula:"$pubA2$"}),ut,Object(a["g"])(r,null,{default:ze((function(){return[ht]})),_:1})]),Object(a["g"])("p",null,[bt,Object(a["g"])(c,{formula:"$pubA1$"}),dt,Object(a["g"])(c,{formula:"$pubA2$"}),mt,Object(a["g"])(c,{formula:"$K_B pubA$"}),ft,Object(a["g"])(c,{formula:"$mBp$"}),pt,Object(a["g"])(c,{formula:"$mBq$"}),gt]),jt,Ot,yt,Object(a["g"])("p",null,[wt,Object(a["g"])(r,null,{default:ze((function(){return[vt]})),_:1}),kt,Object(a["g"])(r,null,{default:ze((function(){return[$t]})),_:1}),At,Object(a["g"])(c,{formula:"$\\mathbb{L}_{KC\\otimes}$"}),Bt,Object(a["g"])(r,null,{default:ze((function(){return[_t]})),_:1}),Et,Object(a["g"])(r,null,{default:ze((function(){return[xt]})),_:1}),Tt,Object(a["g"])(l,{to:{name:"References"}},{default:ze((function(){return[qt]})),_:1}),St]),Ct,Object(a["g"])(c,{formula:"$$E = \\{BrA1, BrA2\\}$$"}),Object(a["g"])(c,{formula:"$$R_A=\\{(e1,e2)| (mBp \\in e1)\\wedge (mBq \\in e2)\\}$$"},null,8,["formula"]),Object(a["g"])(c,{formula:"$$R_B= E \\times E$$"}),Object(a["g"])(c,{formula:"$$\\textnormal{pre}(BrA1)=A1$$"},null,8,["formula"]),Object(a["g"])(c,{formula:"$$\\textnormal{pre}(BrA2)=A2$$"},null,8,["formula"]),It,Object(a["g"])("p",null,[Mt,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ArmBp)=mBp$"},null,8,["formula"]),Rt,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ArmBq)=mBq$"},null,8,["formula"]),Ft]),Object(a["g"])(c,{formula:"$$E = \\{ArmBp, ArmBq\\}$$"}),Object(a["g"])(c,{formula:"$$R_A = E \\times E$$"}),Object(a["g"])(c,{formula:"$$R_B=\\{(e,e)| e \\in E\\}$$"},null,8,["formula"]),Object(a["g"])(c,{formula:"$$\\textnormal{pre}(ArmBp)=mBp$$"},null,8,["formula"]),Object(a["g"])(c,{formula:"$$\\textnormal{pre}(ArmBq)=mBq$$"},null,8,["formula"]),Wt,Ht,Nt,Lt,Kt,Pt,Dt,zt,Jt,Ut,Object(a["g"])("p",null,[Gt,Object(a["g"])(r,null,{default:ze((function(){return[Vt]})),_:1}),Qt,Object(a["g"])(r,null,{default:ze((function(){return[Xt]})),_:1}),Yt]),Object(a["g"])("ul",null,[Object(a["g"])("li",null,[Zt,Object(a["g"])(r,null,{default:ze((function(){return[en]})),_:1}),tn,Object(a["g"])(r,null,{default:ze((function(){return[nn]})),_:1}),an,Object(a["g"])(c,{formula:"$ErA$"}),on,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ErA) = pubA$"},null,8,["formula"]),sn,Object(a["g"])(c,{formula:"$ErA$"}),rn]),Object(a["g"])("li",null,[ln,Object(a["g"])(c,{formula:"$BrA$"}),cn,Object(a["g"])(c,{formula:"$BrE$"}),un,Object(a["g"])(c,{formula:"$\\textnormal{pre}(BrA) = pubA$"},null,8,["formula"]),hn,Object(a["g"])(c,{formula:"$\\textnormal{pre}(BrE) = pubE$"},null,8,["formula"]),bn]),Object(a["g"])("li",null,[dn,Object(a["g"])(c,{formula:"$ErmBp$"}),mn,Object(a["g"])(c,{formula:"$ErmBq$"}),fn,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ErmBp) = pubE, mBp$"},null,8,["formula"]),pn,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ErmBq) = pubE, mBq$"},null,8,["formula"]),gn,Object(a["g"])(c,{formula:"$mBp$"}),jn,Object(a["g"])(c,{formula:"$mBq$"}),On]),Object(a["g"])("li",null,[yn,Object(a["g"])(c,{formula:"$ArmBp$"}),wn,Object(a["g"])(c,{formula:"$ArmBq$"}),vn,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ArmBq) = pubA, mBq$"},null,8,["formula"]),kn,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ArmBq) = pubA, mBq$"},null,8,["formula"])])]),$n,An,Bn,_n,En,xn,Tn,qn,Sn,Object(a["g"])("p",null,[Cn,Object(a["g"])(r,null,{default:ze((function(){return[In]})),_:1}),Mn,Object(a["g"])(r,null,{default:ze((function(){return[Rn]})),_:1}),Fn,Object(a["g"])(r,null,{default:ze((function(){return[Wn]})),_:1}),Hn,Object(a["g"])(r,null,{default:ze((function(){return[Nn]})),_:1}),Ln,Object(a["g"])(c,{formula:"$pubA$"}),Kn,Object(a["g"])(c,{formula:"$pubE$"}),Pn,Object(a["g"])(r,null,{default:ze((function(){return[Dn]})),_:1}),zn,Object(a["g"])(r,null,{default:ze((function(){return[Jn]})),_:1}),Un,Object(a["g"])(r,null,{default:ze((function(){return[Gn]})),_:1}),Vn,Object(a["g"])(l,{to:{name:"Methods"}},{default:ze((function(){return[Qn]})),_:1}),Xn]),Yn,Zn,Object(a["g"])("ul",null,[Object(a["g"])("li",null,[ea,Object(a["g"])(c,{formula:"$mBp$"}),ta,Object(a["g"])(c,{formula:"$mBq$"}),na,Object(a["g"])(c,{formula:"$ErA$"}),aa,Object(a["g"])(c,{formula:"$\\textnormal{pre}(ErA)=pubA$"},null,8,["formula"])]),Object(a["g"])("li",null,[oa,Object(a["g"])(c,{formula:"$\\textnormal{pre}(BrA)=pubA$"},null,8,["formula"]),ia,Object(a["g"])(c,{formula:"$\\textnormal{pre}(BrE)=pubE$"},null,8,["formula"]),sa]),Object(a["g"])("li",null,[ra,Object(a["g"])(c,{formula:"$ErmBp[0]$"}),la,Object(a["g"])(c,{formula:"$ErmBp[0]$"}),ca,Object(a["g"])(c,{formula:"$ErmBq[0]$"}),ua,Object(a["g"])(c,{formula:"$pre(ErmBp[0]) = pubE, mBp$"},null,8,["formula"]),ha,Object(a["g"])(c,{formula:"$pre(ErmBq[0]) = pubE, mBq$"},null,8,["formula"]),ba]),Object(a["g"])("li",null,[da,Object(a["g"])(c,{formula:"$pre(ArmBp[0]) = pubA, mBp$"},null,8,["formula"]),ma,Object(a["g"])(c,{formula:"$pre(ArmBq[0]) = pubA, mBq$"},null,8,["formula"])]),Object(a["g"])("li",null,[fa,Object(a["g"])(c,{formula:"$mBp$"}),pa,Object(a["g"])(c,{formula:"$mBp$"}),ga,Object(a["g"])(c,{formula:"$mBq$"}),ja,Object(a["g"])(c,{formula:"$ErmBp[1]$"}),Oa,Object(a["g"])(c,{formula:"$ErmBq[1]$"}),ya,Object(a["g"])(c,{formula:"$pre(ErmBp[1]) = pubE, mBp$"},null,8,["formula"]),wa,Object(a["g"])(c,{formula:"$pre(ErmBq[1]) = pubE, mBq$"},null,8,["formula"]),va]),Object(a["g"])("li",null,[ka,Object(a["g"])(c,{formula:"$pre(ArmBp[1]) = pubA, mBp$"},null,8,["formula"]),$a,Object(a["g"])(c,{formula:"$pre(ArmBq[1]) = pubA, mBq$"},null,8,["formula"]),Aa])]),Ba,_a,Ea,xa,Ta])}));function Sa(e,t,n,o,i,s){return Object(a["p"])(),Object(a["d"])("span",{ref:"mathJaxEl",innerHTML:n.formula,class:"e-mathjax"},null,8,["innerHTML"])}var Ca={props:["formula"]};Ca.render=Sa;var Ia=Ca,Ma={components:{MathJax:Ia},name:"Formalism"};n("7b26");Ma.render=qa,Ma.__scopeId="data-v-06f47628";var Ra=Ma,Fa={class:"blog"};function Wa(e,t,n,o,i,s){return Object(a["p"])(),Object(a["d"])("div",Fa,[Object(a["g"])("h1",null,Object(a["y"])(e.$route.name),1)])}var Ha={name:"Discussion"};Ha.render=Wa;var Na=Ha,La=Object(a["C"])("data-v-9815b01a");Object(a["s"])("data-v-9815b01a");var Ka={class:"blog"},Pa=Object(a["f"])(" If you want to send some piece of information to "),Da=Object(a["f"])("only"),za=Object(a["f"])(" your friend and no one else, then you will have to have some technique to ensure that no one else is able to read this piece of information. This is where the concept of "),Ja=Object(a["f"])("encryption"),Ua=Object(a["f"])(" comes in. Encryption is the process of converting a message into a secret coded form that cannot be read without knowing how to decode the secret coded form back into the original message. There are two important takeaways from this section about encryption. First of all, understanding how asymmetric key encryption works in general. And secondly, why we cannot decode parts of a message that have been encrypted using the asymmetric encryption algorithm. "),Ga=Object(a["f"])(" At their core, the encryption algorithms can be defined as the symmetric technique having only one key, while the asymmetric technique has two keys. Symmetric encryption uses one key in order to "),Va=Object(a["f"])("both"),Qa=Object(a["f"])(" lock and unlock a piece of information. Asymmetric encryption uses one key in order to lock the information and another key to unlock the information. Symmetric keys are generally not preferred as they can be easily copied or stolen, especially when they are being transferred to someone else who would need to decrypt the information that you send them. Not only would this mean that the message could be decrypted by someone else. It also means that there is no way in which the receiver of a message can be sure that the message comes from the original sender. This leaves us with asymmetric encryption. "),Xa=Object(a["g"])("p",null,"Asymmetric encryption generally works as follows:",-1),Ya=Object(a["g"])("ul",null,[Object(a["g"])("li",null," There is a key that locks information which can be send out into public. Everyone can have access to the public key. "),Object(a["g"])("li",null," There is another key which is kept private and will be used for unlocking any information that was locked using the public key. ")],-1),Za=Object(a["g"])("p",null," This asymmetric key-pair gives a secure way for agents to send information back and forth (as long as both agents have a secure asymmetric key-pair of each other). Take for instance, Alice (on the left) and Bob (on the right) below. Bob wants to send a message, Alice can encrypt it with her public key and decrypt it with her private key. ",-1),eo=Object(a["g"])("div",{class:"image encryptiongif"},null,-1),to=Object(a["g"])("p",null," Understanding the basic process of asymmetric cryptography is important in order to understand the epistemic logic that follows from it, specifically for the interlock protocol. However, to understand the Interlock protocol that will be explained later, we need to have an understanding about why we cannot decode half of an encoded message. ",-1),no=Object(a["g"])("p",null," The other realisation that is important is that we need the entire encrypted message in order to decode it. If we break it into two, and decode one of the halves, we get gibberish back. Somewhat of an analogy might be found in breaking a lock in two. It becomes hard to unlock a half of a lock simply because it is broken. With digital locks, a broken lock cannot be unlocked (unlike real life where a broken lock does unlock the thing hiding behind it). ",-1),ao=Object(a["g"])("p",null," The following section has been added for completeness' sake. It describes an example of how RSA (an asymmetric encryption algorithm) works. We left this in as it might help better understand encryption. The next section (hiding under the button) can safely be skipped, if encryption is clear. ",-1),oo=Object(a["g"])("h2",null,"An Example Encryption Algorithm",-1),io=Object(a["g"])("p",null," Underlying asymmetric public key cryptography is an encryption algorithm which relies on a lot of complex mathematical properties. RSA  is such an encryption algorithm that can be used for asymmetric cryptography. The step-by-step process on how this algorithm works is given below. ",-1),so=Object(a["g"])("p",null," First we will have to generate a RSA key-pair. We can do that as follows: ",-1),ro=Object(a["f"])(" Choose 2 large prime number "),lo=Object(a["f"])("p"),co=Object(a["f"])(" and "),uo=Object(a["f"])("q"),ho=Object(a["f"])(". As an example we can take: "),bo=Object(a["f"])(" Compute "),mo=Object(a["f"])(" and "),fo=Object(a["f"])(" Choose "),po=Object(a["f"])("e"),go=Object(a["f"])(" such that "),jo=Object(a["f"])(" and that "),Oo=Object(a["f"])("e"),yo=Object(a["f"])(" has no common factors with "),wo=Object(a["f"])("z"),vo=Object(a["f"])(". "),ko=Object(a["g"])("br",null,null,-1),$o=Object(a["f"])(" Choose "),Ao=Object(a["f"])("d"),Bo=Object(a["f"])(" such that "),_o=Object(a["f"])(" is exactly divisible by "),Eo=Object(a["f"])("z"),xo=Object(a["f"])(". "),To=Object(a["f"])(" Now we have our public key as "),qo=Object(a["f"])(" and our private key as "),So=Object(a["g"])("p",null,' Now that we have a public and private key-pair, we can encrypt and decrypt messages. In order to encrypt a message, the message first needs to be transformed into a numerical value. If we were now to encrypt the message "Cuddly Llamas", then we would get the following example: ',-1),Co=Object(a["g"])("li",null,[Object(a["f"])(' First, we transform "Cuddly Llamas" into its binary value representation (using ASCII): '),Object(a["g"])("pre",null,"        0100001101110101011001000110010001101100011110010010000\n        0010011000110110001100001011011010110000101110011\n")],-1),Io=Object(a["f"])(" Then encrypt the numerical representation using "),Mo=Object(a["f"])(" for the message, resulting in: "),Ro=Object(a["g"])("pre",null,"        0001100101011100010011011100101111001010010111100101000\n        1011001110011010001101000000010110101000100100011000101\n        1001110011010110101110001000110110110101101011100011010\n        0100\n",-1),Fo=Object(a["f"])(' Note that the if we take half of the encrypted message, it will decrypt to something else than "Cuddly". '),Wo=Object(a["g"])("br",null,null,-1),Ho=Object(a["g"])("br",null,null,-1),No=Object(a["f"])(" Decrypting the encrypted message using "),Lo=Object(a["f"])(" would result in the original message: "),Ko=Object(a["g"])("pre",null,"        0100001101110101011001000110010001101100011110010010000\n        0010011000110110001100001011011010110000101110011\n",-1),Po=Object(a["g"])("li",null,[Object(a["f"])(" Transforming this numerical result back into text gives: "),Object(a["g"])("pre",null,"        Cuddly Llamas\n")],-1);Object(a["q"])();var Do=La((function(e,t,n,o,i,s){var r=Object(a["v"])("it"),l=Object(a["v"])("math-jax");return Object(a["p"])(),Object(a["d"])("div",Ka,[Object(a["g"])("h1",null,Object(a["y"])(e.$route.name),1),Object(a["g"])("p",null,[Pa,Object(a["g"])(r,null,{default:La((function(){return[Da]})),_:1}),za,Object(a["g"])(r,null,{default:La((function(){return[Ja]})),_:1}),Ua]),Object(a["g"])("p",null,[Ga,Object(a["g"])(r,{CLASS:"textit"},{default:La((function(){return[Va]})),_:1}),Qa]),Xa,Ya,Za,eo,to,no,ao,Object(a["g"])("p",null,[Object(a["g"])("button",{type:"button",onClick:t[1]||(t[1]=function(){return s.toggleCollapsible&&s.toggleCollapsible.apply(s,arguments)}),class:{collapsible:!0,active:i.isShowingCollapsible}}," Show Example Encryption Algorithm ",2)]),Object(a["g"])("div",{class:{content:!i.isShowingCollapsible,"content-not-hidden":i.isShowingCollapsible}},[oo,io,so,Object(a["g"])("ol",null,[Object(a["g"])("li",null,[ro,Object(a["g"])(r,null,{default:La((function(){return[lo]})),_:1}),co,Object(a["g"])(r,null,{default:La((function(){return[uo]})),_:1}),ho,Object(a["g"])(l,{formula:"$$p=61$$"}),Object(a["g"])(l,{formula:"$$q=79$$"})]),Object(a["g"])("li",null,[bo,Object(a["g"])(l,{formula:"$n = p q$"}),mo,Object(a["g"])(l,{formula:"$z = (p-1) (q - 1)$"},null,8,["formula"]),Object(a["g"])(l,{formula:"$$n = 61 * 79 = 4819$$"}),Object(a["g"])(l,{formula:"$$z = (61-1)(79-1)=60 * 78 = 4680$$"},null,8,["formula"])]),Object(a["g"])("li",null,[fo,Object(a["g"])(r,null,{default:La((function(){return[po]})),_:1}),go,Object(a["g"])(l,{formula:"$e < z$"}),jo,Object(a["g"])(r,null,{default:La((function(){return[Oo]})),_:1}),yo,Object(a["g"])(r,null,{default:La((function(){return[wo]})),_:1}),vo,ko,Object(a["g"])(l,{formula:"$$e = 19$$"})]),Object(a["g"])("li",null,[$o,Object(a["g"])(r,null,{default:La((function(){return[Ao]})),_:1}),Bo,Object(a["g"])(l,{formula:"ed - 1"}),_o,Object(a["g"])(r,null,{default:La((function(){return[Eo]})),_:1}),xo,Object(a["g"])(l,{formula:"$$d = 739$$"})]),Object(a["g"])("li",null,[To,Object(a["g"])(l,{formula:"$(n, e)$"},null,8,["formula"]),qo,Object(a["g"])(l,{formula:"$(n, d)$"},null,8,["formula"]),Object(a["g"])(l,{formula:"$$Key_{public} = (4819,19)$$"},null,8,["formula"]),Object(a["g"])(l,{formula:"$$Key_{private} = (4819,739)$$"},null,8,["formula"])])]),So,Object(a["g"])("ol",null,[Co,Object(a["g"])("li",null,[Io,Object(a["g"])(l,{formula:"$C = m ^ e (mod N)$"},null,8,["formula"]),Mo,Ro,Fo,Wo,Ho]),Object(a["g"])("li",null,[No,Object(a["g"])(l,{formula:"$m = C ^ d (mod N)$"},null,8,["formula"]),Lo,Ko]),Po])],2)])})),zo={components:{MathJax:Ia},name:"Encryption",data:function(){return{isShowingCollapsible:!1}},mounted:function(){try{window.MathJax.typeset()}catch(e){console.error(e)}},methods:{toggleCollapsible:function(){console.log("collapsing toggle"),this.isShowingCollapsible=!this.isShowingCollapsible}}};n("2c98");zo.render=Do,zo.__scopeId="data-v-9815b01a";var Jo=zo,Uo={style:{display:"flex","padding-top":"100px","justify-content":"center","align-items":"center","flex-direction":"column"}},Go=Object(a["g"])("div",null,[Object(a["g"])("h1",null,"Error 404 - Page not found")],-1),Vo=Object(a["f"])(" Perhaps you are looking for "),Qo=Object(a["f"])("home?");function Xo(e,t,n,o,i,s){var r=Object(a["v"])("router-link");return Object(a["p"])(),Object(a["d"])("div",Uo,[Go,Object(a["g"])("div",null,[Object(a["g"])("h2",null,[Vo,Object(a["g"])(r,{to:{name:"Home"}},{default:Object(a["B"])((function(){return[Qo]})),_:1})])])])}var Yo={name:"Home"};Yo.render=Xo;var Zo=Yo,ei={class:"blog"},ti=Object(a["g"])("ol",null,[Object(a["g"])("li",null," Malvin Gattinger and Jan Van Eijck. “Towards model checking crypto-graphic protocols with dynamic epistemic logic”. In: Proc. LAMAS. Cite-seer. 2015, pp. 1–14. "),Object(a["g"])("li",null," Ronald L Rivest and Adi Shamir. “How to expose an eavesdropper”. In: Communications of the ACM27.4 (1984), pp. 393–394. "),Object(a["g"])("li",null," Hans Van Ditmarsch, Wiebe van Der Hoek, and Barteld Kooi. Dynamic epistemic logic. Vol. 337. Springer Science & Business Media, 2007. "),Object(a["g"])("li",null," Daniel Solove (2007). I've got nothing to hide and other misunderstandings of privacy. San Diego L. Rev., 44, 745. ")],-1),ni=Object(a["g"])("p",null," Not all of the code for this website was written by us (although it was heavily modified for our purposes), an informal reference is made to the location where the relevant code was found: ",-1),ai=Object(a["g"])("ul",null,[Object(a["g"])("li",null," Responsive sidebar menu (22-06-2021): https://www.cssscript.com/css-responsive-hamburger-navigation/ ")],-1);function oi(e,t,n,o,i,s){return Object(a["p"])(),Object(a["d"])("div",ei,[Object(a["g"])("h1",null,Object(a["y"])(e.$route.name),1),ti,ni,ai])}var ii={name:"Methods"};ii.render=oi;var si=ii,ri=[{path:"/",name:"Home",component:le},{path:"/formalism",name:"Formalism",component:Ra},{path:"/encryption",name:"Encryption",component:Jo},{path:"/methods",name:"Methods",component:ve},{path:"/discussion",name:"Discussion",component:Na},{path:"/simulation",name:"Simulation",component:ge},{path:"/references",name:"References",component:si},{path:"/:pathMatch(.*)*",component:Zo}],li=Object(M["a"])({history:Object(M["b"])(),base:"/eavesdropping-lamas/",routes:ri}),ci=li;Object(a["c"])(I).use(ci).mount("#app")},"5d6d":function(e,t,n){},"63b4":function(e,t,n){e.exports=n.p+"img/perfect_communication_1.4e5ec8af.jpg"},"68fc":function(e,t,n){e.exports=n.p+"img/eavesdropping_1.a635af96.jpg"},"7b26":function(e,t,n){"use strict";n("e99b")},"81a2":function(e,t,n){e.exports=n.p+"img/perf_kripke.1f9ac272.png"},8311:function(e,t,n){e.exports=n.p+"img/perfect_communication_2.7ab74b98.jpg"},"836e":function(e,t,n){},"91e8":function(e,t,n){e.exports=n.p+"img/interlock_3.68bef7e2.jpg"},"99aa":function(e,t,n){e.exports=n.p+"img/interlock_2.439d094d.jpg"},b82f:function(e,t,n){"use strict";n("2d3d")},c877:function(e,t,n){"use strict";n("0ad8")},d30d:function(e,t,n){e.exports=n.p+"img/interlock_1.8dd97026.jpg"},d47f:function(e,t,n){e.exports=n.p+"img/eavesdropping_2.c58f3ea9.jpg"},e99b:function(e,t,n){},ef76:function(e,t,n){"use strict";n("836e")},f51d:function(e,t,n){e.exports=n.p+"img/incognito_logo.5acf4359.png"}});
//# sourceMappingURL=app.28043a36.js.map